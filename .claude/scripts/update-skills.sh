#!/usr/bin/env bash
#
# update-skills.sh - Update agent skills from remote repository
# Repository: https://github.com/buiducnhat/agent-skills.git
#
# Location: .claude/scripts/update-skills.sh
# Compatible with bash 3.2+ (macOS default) and bash 4+
#

set -euo pipefail

# Configuration
REPO_URL="https://github.com/buiducnhat/agent-skills.git"
REPO_BRANCH="main"
MANIFEST_FILE=".claude/.upstream-manifest"
BACKUP_DIR=".claude-backup"

# Script state - resolve to project root (two levels up from .claude/scripts/)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
TEMP_DIR=""
MANIFEST_TEMP=""
DRY_RUN=false
FORCE=false
VERBOSE=false
NO_BACKUP=false
CUSTOM_BACKUP_DIR=""
MAX_BACKUPS=3

# Change to project root for all operations
cd "$PROJECT_ROOT"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

log_verbose() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
    fi
}

cleanup() {
    if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
        log_verbose "Cleaning up temp directory: $TEMP_DIR"
        rm -rf "$TEMP_DIR"
    fi
    if [[ -n "$MANIFEST_TEMP" && -f "$MANIFEST_TEMP" ]]; then
        rm -f "$MANIFEST_TEMP"
    fi
}

trap cleanup EXIT

# Get file hash (cross-platform)
get_file_hash() {
    local file="$1"
    if command -v sha256sum &> /dev/null; then
        sha256sum "$file" | cut -d' ' -f1
    elif command -v shasum &> /dev/null; then
        shasum -a 256 "$file" | cut -d' ' -f1
    else
        # Fallback: use md5
        if command -v md5sum &> /dev/null; then
            md5sum "$file" | cut -d' ' -f1
        else
            md5 -q "$file"
        fi
    fi
}

# Get value from manifest for a path
# Usage: get_manifest_entry "path" -> outputs "hash:version" or empty
get_manifest_entry() {
    local search_path="$1"
    if [[ ! -f "$MANIFEST_FILE" ]]; then
        return 1
    fi
    # Use -F for literal string matching to avoid regex issues with special chars
    grep -F "${search_path}:" "$MANIFEST_FILE" 2>/dev/null | head -1 | cut -d':' -f2-3 || true
}

# Check if path exists in manifest
is_in_manifest() {
    local search_path="$1"
    if [[ ! -f "$MANIFEST_FILE" ]]; then
        return 1
    fi
    grep -qF "${search_path}:" "$MANIFEST_FILE" 2>/dev/null
}

# Check if skill is tracked in manifest (any file under skill dir)
is_upstream_skill() {
    local skill_name="$1"
    if [[ ! -f "$MANIFEST_FILE" ]]; then
        return 1
    fi
    # Check if manifest contains entries for this skill (format: .claude/skills/skillname/...)
    grep -qE "^\.claude/skills/${skill_name}/" "$MANIFEST_FILE" 2>/dev/null
}

# Get all tracked file paths from manifest
get_manifest_paths() {
    if [[ ! -f "$MANIFEST_FILE" ]]; then
        return
    fi
    grep -v '^#' "$MANIFEST_FILE" | grep -v '^[a-z_]*=' | grep -v '^$' | cut -d':' -f1
}

# Write manifest header
write_manifest_header() {
    local commit="$1"
    local version="$2"
    local manifest_file="$3"

    cat > "$manifest_file" << EOF
# Agent Skills Upstream Manifest
# Generated by update-skills.sh
# DO NOT EDIT MANUALLY
#
version=$version
upstream_repo=$REPO_URL
upstream_commit=$commit
updated_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Files (format: path:hash:version)
EOF
}

# Add entry to manifest
add_manifest_entry() {
    local path="$1"
    local hash="$2"
    local version="$3"
    local manifest_file="$4"
    echo "${path}:${hash}:${version}" >> "$manifest_file"
}

# Get list of local (non-upstream) skills
get_local_skills() {
    if [[ ! -d ".claude/skills" ]]; then
        return
    fi

    for skill_dir in .claude/skills/*/; do
        if [[ -d "$skill_dir" ]]; then
            local skill_name
            skill_name=$(basename "$skill_dir")

            if ! is_upstream_skill "$skill_name"; then
                echo "$skill_name"
            fi
        fi
    done
}

show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Update agent skills from the remote repository while preserving local custom skills.

OPTIONS:
    --dry-run           Show what would be changed without making changes
    --force             Overwrite all upstream skills, even if locally modified
    --status            Show current status (upstream vs local skills)
    --init-manifest     Initialize manifest for existing installation
    --backup-dir PATH   Custom backup directory (default: .claude-backup)
    --max-backups N     Keep only N most recent backups (default: 3)
    --no-backup         Skip backup before update (not recommended)
    -v, --verbose       Enable verbose output
    -h, --help          Show this help message

EXAMPLES:
    $(basename "$0")                  # Update skills from remote
    $(basename "$0") --dry-run        # Preview changes
    $(basename "$0") --status         # Show current status
    $(basename "$0") --init-manifest  # Initialize manifest for existing install

REPOSITORY: $REPO_URL

EOF
}

parse_args() {
    local action="update"

    while [[ $# -gt 0 ]]; do
        case $1 in
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --force)
                FORCE=true
                shift
                ;;
            --status)
                action="status"
                shift
                ;;
            --init-manifest)
                action="init-manifest"
                shift
                ;;
            --backup-dir)
                CUSTOM_BACKUP_DIR="$2"
                shift 2
                ;;
            --max-backups)
                MAX_BACKUPS="$2"
                shift 2
                ;;
            --no-backup)
                NO_BACKUP=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    echo "$action"
}

check_prerequisites() {
    # Check for git
    if ! command -v git &> /dev/null; then
        log_error "git is required but not installed."
        exit 1
    fi

    # Check we're in a directory that looks like a project
    if [[ ! -d ".git" && ! -f "package.json" && ! -f "Cargo.toml" && ! -f "go.mod" ]]; then
        log_warn "This doesn't appear to be a project root directory."
        read -p "Continue anyway? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 1
        fi
    fi
}

# ============================================
# Backup Management
# ============================================

# Clean up old backups, keeping only the most recent N
cleanup_old_backups() {
    local backup_prefix="${CUSTOM_BACKUP_DIR:-$BACKUP_DIR}"
    local max_to_keep="$MAX_BACKUPS"

    # Find all backup directories matching the pattern
    local backups=()
    while IFS= read -r dir; do
        if [[ -d "$dir" ]]; then
            backups+=("$dir")
        fi
    done < <(ls -dt "${backup_prefix}"_* 2>/dev/null || true)

    local count=${#backups[@]}
    if [[ $count -le $max_to_keep ]]; then
        log_verbose "Found $count backups, keeping all (max: $max_to_keep)"
        return
    fi

    local to_delete=$((count - max_to_keep))
    log_info "Cleaning up $to_delete old backup(s) (keeping $max_to_keep most recent)"

    # Delete oldest backups (they are at the end of the sorted list)
    for ((i = max_to_keep; i < count; i++)); do
        local old_backup="${backups[$i]}"
        if [[ "$DRY_RUN" == true ]]; then
            log_info "[DRY RUN] Would remove old backup: $old_backup"
        else
            log_verbose "Removing old backup: $old_backup"
            rm -rf "$old_backup"
        fi
    done
}

create_backup() {
    if [[ "$NO_BACKUP" == true ]]; then
        log_warn "Skipping backup (--no-backup specified)"
        return
    fi

    local backup_path="${CUSTOM_BACKUP_DIR:-$BACKUP_DIR}"
    local timestamp
    timestamp=$(date +"%Y%m%d_%H%M%S")
    local backup_name="${backup_path}_${timestamp}"

    if [[ -d ".claude" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            log_info "[DRY RUN] Would create backup at $backup_name/"
            return
        fi

        log_info "Creating backup at $backup_name/"
        mkdir -p "$backup_name"
        cp -R .claude "$backup_name/"

        if [[ -f "CLAUDE.md" ]]; then
            cp CLAUDE.md "$backup_name/"
        fi

        log_success "Backup created at $backup_name/"

        # Clean up old backups
        cleanup_old_backups
    fi
}

fetch_upstream() {
    TEMP_DIR=$(mktemp -d)
    # Resolve to canonical path (fixes macOS /var -> /private/var symlink issue)
    TEMP_DIR=$(cd "$TEMP_DIR" && pwd -P)
    log_info "Fetching latest from $REPO_URL..."

    if ! git clone --depth 1 --branch "$REPO_BRANCH" "$REPO_URL" "$TEMP_DIR" 2>/dev/null; then
        log_error "Failed to clone repository"
        exit 1
    fi

    log_success "Fetched latest version"
    log_verbose "Temp directory: $TEMP_DIR"
}

get_upstream_commit() {
    git -C "$TEMP_DIR" rev-parse HEAD
}

get_upstream_version() {
    # Try to get version from package.json or default to commit short hash
    if [[ -f "$TEMP_DIR/package.json" ]]; then
        grep -o '"version":[[:space:]]*"[^"]*"' "$TEMP_DIR/package.json" 2>/dev/null | cut -d'"' -f4 || get_upstream_commit | head -c 7
    else
        get_upstream_commit | head -c 7
    fi
}

# Sync a single file from upstream
sync_file() {
    local src="$1"
    local dst="$2"
    local rel_path="$3"
    local version="$4"

    if [[ "$DRY_RUN" == true ]]; then
        if [[ -f "$dst" ]]; then
            if ! diff -q "$src" "$dst" > /dev/null 2>&1; then
                log_info "[DRY RUN] Would update: $rel_path"
            else
                log_verbose "[DRY RUN] No changes: $rel_path"
            fi
        else
            log_info "[DRY RUN] Would create: $rel_path"
        fi
        return
    fi

    # Create parent directory if needed
    mkdir -p "$(dirname "$dst")"

    # Log what we're doing
    if [[ -f "$dst" ]]; then
        if ! diff -q "$src" "$dst" > /dev/null 2>&1; then
            log_verbose "Updating: $rel_path"
        else
            log_verbose "Unchanged: $rel_path"
        fi
    else
        log_verbose "Creating: $rel_path"
    fi

    # Copy file
    cp "$src" "$dst"

    # Add to manifest temp file
    local hash
    hash=$(get_file_hash "$dst")
    add_manifest_entry "$rel_path" "$hash" "$version" "$MANIFEST_TEMP"
}

# Sync a directory from upstream (preserving local additions)
sync_directory() {
    local src_dir="$1"
    local dst_dir="$2"
    local base_rel="$3"
    local version="$4"

    # Find all files in source
    while IFS= read -r src_file; do
        local rel_path="${src_file#$src_dir/}"
        local full_rel="${base_rel}/${rel_path}"
        local dst_file="${dst_dir}/${rel_path}"

        sync_file "$src_file" "$dst_file" "$full_rel" "$version"
    done < <(find "$src_dir" -type f)
}

do_update() {
    log_info "Starting update..."

    # Identify local skills before update
    local local_skills
    local_skills=$(get_local_skills | tr '\n' ' ')
    if [[ -n "$local_skills" ]]; then
        log_info "Local skills that will be preserved: $local_skills"
    fi

    # Create backup
    create_backup

    # Fetch upstream
    fetch_upstream

    local commit version
    commit=$(get_upstream_commit)
    version=$(get_upstream_version)

    log_info "Upstream version: $version (commit: ${commit:0:7})"

    # Create temp manifest file
    MANIFEST_TEMP=$(mktemp)
    write_manifest_header "$commit" "$version" "$MANIFEST_TEMP"

    # Sync .claude/lib/
    if [[ -d "$TEMP_DIR/.claude/lib" ]]; then
        log_info "Updating .claude/lib/..."
        sync_directory "$TEMP_DIR/.claude/lib" ".claude/lib" ".claude/lib" "$version"
    fi

    # Sync .claude/skills/ (only upstream skills)
    if [[ -d "$TEMP_DIR/.claude/skills" ]]; then
        log_info "Updating upstream skills..."

        for skill_dir in "$TEMP_DIR/.claude/skills"/*/; do
            if [[ -d "$skill_dir" ]]; then
                local skill_name
                skill_name=$(basename "$skill_dir")
                local dst_skill=".claude/skills/$skill_name"

                # Check if this is a local skill we should preserve
                if echo "$local_skills" | grep -qw "$skill_name"; then
                    log_warn "Skipping local skill: $skill_name (would conflict)"
                    continue
                fi

                # Check if locally modified and not forcing
                local skill_file=".claude/skills/$skill_name/SKILL.md"
                if [[ -f "$skill_file" && "$FORCE" != true ]]; then
                    local stored
                    stored=$(get_manifest_entry "$skill_file") || true
                    if [[ -n "$stored" ]]; then
                        local stored_hash
                        stored_hash=$(echo "$stored" | cut -d':' -f1)
                        local current_hash
                        current_hash=$(get_file_hash "$skill_file")

                        if [[ "$stored_hash" != "$current_hash" ]]; then
                            log_warn "Skipping modified skill: $skill_name (use --force to overwrite)"
                            log_verbose "  Stored hash: $stored_hash"
                            log_verbose "  Current hash: $current_hash"
                            continue
                        fi
                    else
                        log_verbose "No manifest entry for $skill_file, will update"
                    fi
                fi

                log_verbose "Updating skill: $skill_name"
                sync_directory "$skill_dir" "$dst_skill" ".claude/skills/$skill_name" "$version"
            fi
        done
    fi

    # Sync .claude/scripts/
    if [[ -d "$TEMP_DIR/.claude/scripts" ]]; then
        log_info "Updating .claude/scripts/..."
        sync_directory "$TEMP_DIR/.claude/scripts" ".claude/scripts" ".claude/scripts" "$version"
        if [[ "$DRY_RUN" != true ]]; then
            chmod +x .claude/scripts/*.sh 2>/dev/null || true
        fi
    fi

    # Sync CLAUDE.md
    if [[ -f "$TEMP_DIR/CLAUDE.md" ]]; then
        log_info "Updating CLAUDE.md..."
        sync_file "$TEMP_DIR/CLAUDE.md" "CLAUDE.md" "CLAUDE.md" "$version"
    fi

    # Write updated manifest
    if [[ "$DRY_RUN" != true ]]; then
        mv "$MANIFEST_TEMP" "$MANIFEST_FILE"
        MANIFEST_TEMP=""
        log_verbose "Manifest written to $MANIFEST_FILE"
    fi

    echo ""
    log_success "Update complete!"

    if [[ -n "$local_skills" ]]; then
        log_info "Your custom skills were preserved: $local_skills"
    fi

    if [[ "$DRY_RUN" == true ]]; then
        log_warn "This was a dry run. No changes were made."
    fi
}

do_status() {
    log_info "Checking status..."

    if [[ ! -f "$MANIFEST_FILE" ]]; then
        log_warn "No manifest found. Run with --init-manifest first."
        log_info ""
        log_info "Current .claude/ contents:"
        if [[ -d ".claude/skills" ]]; then
            for skill_dir in .claude/skills/*/; do
                if [[ -d "$skill_dir" ]]; then
                    local skill_name
                    skill_name=$(basename "$skill_dir")
                    echo "  - $skill_name (unknown origin)"
                fi
            done
        fi
        return
    fi

    echo ""
    echo "=== Upstream Skills (from repository) ==="
    local upstream_count=0
    local modified_count=0
    local printed_skills=""

    while IFS=: read -r path hash version || [[ -n "$path" ]]; do
        # Skip comments, empty lines, and metadata
        [[ "$path" =~ ^#.*$ || -z "$path" ]] && continue
        [[ "$path" =~ ^[a-z_]+=.*$ ]] && continue

        if [[ "$path" == ".claude/skills/"* ]]; then
            local skill_name
            skill_name=$(echo "$path" | cut -d'/' -f3)

            # Only print each skill once
            if echo "$printed_skills" | grep -qw "$skill_name"; then
                continue
            fi
            printed_skills="$printed_skills $skill_name"

            if [[ -f "$path" ]]; then
                local current_hash
                current_hash=$(get_file_hash "$path")
                if [[ "$hash" == "$current_hash" ]]; then
                    echo "  ✓ $skill_name"
                else
                    echo "  ✎ $skill_name (locally modified)"
                    modified_count=$((modified_count + 1))
                fi
            else
                echo "  ✗ $skill_name (deleted locally)"
            fi
            upstream_count=$((upstream_count + 1))
        fi
    done < "$MANIFEST_FILE"

    echo ""
    echo "=== Local Skills (user-created) ==="
    local local_count=0

    if [[ -d ".claude/skills" ]]; then
        for skill_dir in .claude/skills/*/; do
            if [[ -d "$skill_dir" ]]; then
                local skill_name
                skill_name=$(basename "$skill_dir")

                if ! is_upstream_skill "$skill_name"; then
                    echo "  ★ $skill_name"
                    local_count=$((local_count + 1))
                fi
            fi
        done
    fi

    if [[ $local_count -eq 0 ]]; then
        echo "  (none)"
    fi

    echo ""
    echo "=== Summary ==="
    echo "  Upstream skills: $upstream_count"
    echo "  Modified locally: $modified_count"
    echo "  Local/custom skills: $local_count"
}

do_init_manifest() {
    log_info "Initializing manifest for existing installation..."

    if [[ ! -d ".claude" ]]; then
        log_error "No .claude directory found. Nothing to initialize."
        exit 1
    fi

    if [[ -f "$MANIFEST_FILE" ]]; then
        log_warn "Manifest already exists at $MANIFEST_FILE"
        read -p "Overwrite? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit 0
        fi
    fi

    # Clone repo to get list of upstream files
    TEMP_DIR=$(mktemp -d)
    log_info "Cloning repository to identify upstream files..."

    git clone --depth 1 --branch "$REPO_BRANCH" "$REPO_URL" "$TEMP_DIR" 2>/dev/null

    local commit
    commit=$(git -C "$TEMP_DIR" rev-parse HEAD)

    # Create manifest
    MANIFEST_TEMP=$(mktemp)
    write_manifest_header "$commit" "1.0.0" "$MANIFEST_TEMP"

    local file_count=0

    # Find all files in upstream
    while IFS= read -r file; do
        local rel_path="${file#$TEMP_DIR/}"

        # Only track .claude/ and CLAUDE.md
        if [[ "$rel_path" == ".claude/"* || "$rel_path" == "CLAUDE.md" ]]; then
            # Check if file exists locally
            if [[ -f "$rel_path" ]]; then
                local hash
                hash=$(get_file_hash "$rel_path")
                add_manifest_entry "$rel_path" "$hash" "1.0.0" "$MANIFEST_TEMP"
                log_verbose "Tracking: $rel_path"
                file_count=$((file_count + 1))
            fi
        fi
    done < <(find "$TEMP_DIR" -type f)

    # Write manifest
    mv "$MANIFEST_TEMP" "$MANIFEST_FILE"
    MANIFEST_TEMP=""

    log_success "Manifest initialized with $file_count files"
    log_info "Your custom skills will now be preserved during updates."
}

main() {
    local action
    action=$(parse_args "$@")

    check_prerequisites

    case "$action" in
        update)
            do_update
            ;;
        status)
            do_status
            ;;
        init-manifest)
            do_init_manifest
            ;;
    esac
}

# Run main
main "$@"
